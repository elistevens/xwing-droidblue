#define _CFFI_
#include <Python.h>
#ifdef __cplusplus
extern "C" {
#endif
#include <stddef.h>

/* This part is from file 'cffi/parse_c_type.h'.  It is copied at the
   beginning of C sources generated by CFFI's ffi.set_source(). */

typedef void *_cffi_opcode_t;

#define _CFFI_OP(opcode, arg)   (_cffi_opcode_t)(opcode | (((uintptr_t)(arg)) << 8))
#define _CFFI_GETOP(cffi_opcode)    ((unsigned char)(uintptr_t)cffi_opcode)
#define _CFFI_GETARG(cffi_opcode)   (((intptr_t)cffi_opcode) >> 8)

#define _CFFI_OP_PRIMITIVE       1
#define _CFFI_OP_POINTER         3
#define _CFFI_OP_ARRAY           5
#define _CFFI_OP_OPEN_ARRAY      7
#define _CFFI_OP_STRUCT_UNION    9
#define _CFFI_OP_ENUM           11
#define _CFFI_OP_FUNCTION       13
#define _CFFI_OP_FUNCTION_END   15
#define _CFFI_OP_NOOP           17
#define _CFFI_OP_BITFIELD       19
#define _CFFI_OP_TYPENAME       21
#define _CFFI_OP_CPYTHON_BLTN_V 23   // varargs
#define _CFFI_OP_CPYTHON_BLTN_N 25   // noargs
#define _CFFI_OP_CPYTHON_BLTN_O 27   // O  (i.e. a single arg)
#define _CFFI_OP_CONSTANT       29
#define _CFFI_OP_CONSTANT_INT   31
#define _CFFI_OP_GLOBAL_VAR     33
#define _CFFI_OP_DLOPEN_FUNC    35
#define _CFFI_OP_DLOPEN_CONST   37
#define _CFFI_OP_GLOBAL_VAR_F   39
#define _CFFI_OP_EXTERN_PYTHON  41

#define _CFFI_PRIM_VOID          0
#define _CFFI_PRIM_BOOL          1
#define _CFFI_PRIM_CHAR          2
#define _CFFI_PRIM_SCHAR         3
#define _CFFI_PRIM_UCHAR         4
#define _CFFI_PRIM_SHORT         5
#define _CFFI_PRIM_USHORT        6
#define _CFFI_PRIM_INT           7
#define _CFFI_PRIM_UINT          8
#define _CFFI_PRIM_LONG          9
#define _CFFI_PRIM_ULONG        10
#define _CFFI_PRIM_LONGLONG     11
#define _CFFI_PRIM_ULONGLONG    12
#define _CFFI_PRIM_FLOAT        13
#define _CFFI_PRIM_DOUBLE       14
#define _CFFI_PRIM_LONGDOUBLE   15

#define _CFFI_PRIM_WCHAR        16
#define _CFFI_PRIM_INT8         17
#define _CFFI_PRIM_UINT8        18
#define _CFFI_PRIM_INT16        19
#define _CFFI_PRIM_UINT16       20
#define _CFFI_PRIM_INT32        21
#define _CFFI_PRIM_UINT32       22
#define _CFFI_PRIM_INT64        23
#define _CFFI_PRIM_UINT64       24
#define _CFFI_PRIM_INTPTR       25
#define _CFFI_PRIM_UINTPTR      26
#define _CFFI_PRIM_PTRDIFF      27
#define _CFFI_PRIM_SIZE         28
#define _CFFI_PRIM_SSIZE        29
#define _CFFI_PRIM_INT_LEAST8   30
#define _CFFI_PRIM_UINT_LEAST8  31
#define _CFFI_PRIM_INT_LEAST16  32
#define _CFFI_PRIM_UINT_LEAST16 33
#define _CFFI_PRIM_INT_LEAST32  34
#define _CFFI_PRIM_UINT_LEAST32 35
#define _CFFI_PRIM_INT_LEAST64  36
#define _CFFI_PRIM_UINT_LEAST64 37
#define _CFFI_PRIM_INT_FAST8    38
#define _CFFI_PRIM_UINT_FAST8   39
#define _CFFI_PRIM_INT_FAST16   40
#define _CFFI_PRIM_UINT_FAST16  41
#define _CFFI_PRIM_INT_FAST32   42
#define _CFFI_PRIM_UINT_FAST32  43
#define _CFFI_PRIM_INT_FAST64   44
#define _CFFI_PRIM_UINT_FAST64  45
#define _CFFI_PRIM_INTMAX       46
#define _CFFI_PRIM_UINTMAX      47

#define _CFFI__NUM_PRIM         48
#define _CFFI__UNKNOWN_PRIM           (-1)
#define _CFFI__UNKNOWN_FLOAT_PRIM     (-2)
#define _CFFI__UNKNOWN_LONG_DOUBLE    (-3)

#define _CFFI__IO_FILE_STRUCT         (-1)


struct _cffi_global_s {
    const char *name;
    void *address;
    _cffi_opcode_t type_op;
    void *size_or_direct_fn;  // OP_GLOBAL_VAR: size, or 0 if unknown
                              // OP_CPYTHON_BLTN_*: addr of direct function
};

struct _cffi_getconst_s {
    unsigned long long value;
    const struct _cffi_type_context_s *ctx;
    int gindex;
};

struct _cffi_struct_union_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_STRUCT_UNION
    int flags;               // _CFFI_F_* flags below
    size_t size;
    int alignment;
    int first_field_index;   // -> _cffi_fields array
    int num_fields;
};
#define _CFFI_F_UNION         0x01   // is a union, not a struct
#define _CFFI_F_CHECK_FIELDS  0x02   // complain if fields are not in the
                                     // "standard layout" or if some are missing
#define _CFFI_F_PACKED        0x04   // for CHECK_FIELDS, assume a packed struct
#define _CFFI_F_EXTERNAL      0x08   // in some other ffi.include()
#define _CFFI_F_OPAQUE        0x10   // opaque

struct _cffi_field_s {
    const char *name;
    size_t field_offset;
    size_t field_size;
    _cffi_opcode_t field_type_op;
};

struct _cffi_enum_s {
    const char *name;
    int type_index;          // -> _cffi_types, on a OP_ENUM
    int type_prim;           // _CFFI_PRIM_xxx
    const char *enumerators; // comma-delimited string
};

struct _cffi_typename_s {
    const char *name;
    int type_index;   /* if opaque, points to a possibly artificial
                         OP_STRUCT which is itself opaque */
};

struct _cffi_type_context_s {
    _cffi_opcode_t *types;
    const struct _cffi_global_s *globals;
    const struct _cffi_field_s *fields;
    const struct _cffi_struct_union_s *struct_unions;
    const struct _cffi_enum_s *enums;
    const struct _cffi_typename_s *typenames;
    int num_globals;
    int num_struct_unions;
    int num_enums;
    int num_typenames;
    const char *const *includes;
    int num_types;
    int flags;      /* future extension */
};

struct _cffi_parse_info_s {
    const struct _cffi_type_context_s *ctx;
    _cffi_opcode_t *output;
    unsigned int output_size;
    size_t error_location;
    const char *error_message;
};

struct _cffi_externpy_s {
    const char *name;
    size_t size_of_result;
    void *reserved1, *reserved2;
};

#ifdef _CFFI_INTERNAL
static int parse_c_type(struct _cffi_parse_info_s *info, const char *input);
static int search_in_globals(const struct _cffi_type_context_s *ctx,
                             const char *search, size_t search_len);
static int search_in_struct_unions(const struct _cffi_type_context_s *ctx,
                                   const char *search, size_t search_len);
#endif

/* this block of #ifs should be kept exactly identical between
   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py
   and cffi/_cffi_include.h */
#if defined(_MSC_VER)
# include <malloc.h>   /* for alloca() */
# if _MSC_VER < 1600   /* MSVC < 2010 */
   typedef __int8 int8_t;
   typedef __int16 int16_t;
   typedef __int32 int32_t;
   typedef __int64 int64_t;
   typedef unsigned __int8 uint8_t;
   typedef unsigned __int16 uint16_t;
   typedef unsigned __int32 uint32_t;
   typedef unsigned __int64 uint64_t;
   typedef __int8 int_least8_t;
   typedef __int16 int_least16_t;
   typedef __int32 int_least32_t;
   typedef __int64 int_least64_t;
   typedef unsigned __int8 uint_least8_t;
   typedef unsigned __int16 uint_least16_t;
   typedef unsigned __int32 uint_least32_t;
   typedef unsigned __int64 uint_least64_t;
   typedef __int8 int_fast8_t;
   typedef __int16 int_fast16_t;
   typedef __int32 int_fast32_t;
   typedef __int64 int_fast64_t;
   typedef unsigned __int8 uint_fast8_t;
   typedef unsigned __int16 uint_fast16_t;
   typedef unsigned __int32 uint_fast32_t;
   typedef unsigned __int64 uint_fast64_t;
   typedef __int64 intmax_t;
   typedef unsigned __int64 uintmax_t;
# else
#  include <stdint.h>
# endif
# if _MSC_VER < 1800   /* MSVC < 2013 */
   typedef unsigned char _Bool;
# endif
#else
# include <stdint.h>
# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)
#  include <alloca.h>
# endif
#endif

#ifdef __GNUC__
# define _CFFI_UNUSED_FN  __attribute__((unused))
#else
# define _CFFI_UNUSED_FN  /* nothing */
#endif

#ifdef __cplusplus
# ifndef _Bool
#  define _Bool bool   /* semi-hackish: C++ has no _Bool; bool is builtin */
# endif
#endif

/**********  CPython-specific section  **********/
#ifndef PYPY_VERSION


#if PY_MAJOR_VERSION >= 3
# define PyInt_FromLong PyLong_FromLong
#endif

#define _cffi_from_c_double PyFloat_FromDouble
#define _cffi_from_c_float PyFloat_FromDouble
#define _cffi_from_c_long PyInt_FromLong
#define _cffi_from_c_ulong PyLong_FromUnsignedLong
#define _cffi_from_c_longlong PyLong_FromLongLong
#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong

#define _cffi_to_c_double PyFloat_AsDouble
#define _cffi_to_c_float PyFloat_AsDouble

#define _cffi_from_c_int(x, type)                                        \
    (((type)-1) > 0 ? /* unsigned */                                     \
        (sizeof(type) < sizeof(long) ?                                   \
            PyInt_FromLong((long)x) :                                    \
         sizeof(type) == sizeof(long) ?                                  \
            PyLong_FromUnsignedLong((unsigned long)x) :                  \
            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \
        (sizeof(type) <= sizeof(long) ?                                  \
            PyInt_FromLong((long)x) :                                    \
            PyLong_FromLongLong((long long)x)))

#define _cffi_to_c_int(o, type)                                          \
    ((type)(                                                             \
     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \
                                         : (type)_cffi_to_c_i8(o)) :     \
     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \
                                         : (type)_cffi_to_c_i16(o)) :    \
     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \
                                         : (type)_cffi_to_c_i32(o)) :    \
     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \
                                         : (type)_cffi_to_c_i64(o)) :    \
     (Py_FatalError("unsupported size for type " #type), (type)0)))

#define _cffi_to_c_i8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[1])
#define _cffi_to_c_u8                                                    \
                 ((int(*)(PyObject *))_cffi_exports[2])
#define _cffi_to_c_i16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[3])
#define _cffi_to_c_u16                                                   \
                 ((int(*)(PyObject *))_cffi_exports[4])
#define _cffi_to_c_i32                                                   \
                 ((int(*)(PyObject *))_cffi_exports[5])
#define _cffi_to_c_u32                                                   \
                 ((unsigned int(*)(PyObject *))_cffi_exports[6])
#define _cffi_to_c_i64                                                   \
                 ((long long(*)(PyObject *))_cffi_exports[7])
#define _cffi_to_c_u64                                                   \
                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])
#define _cffi_to_c_char                                                  \
                 ((int(*)(PyObject *))_cffi_exports[9])
#define _cffi_from_c_pointer                                             \
    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[10])
#define _cffi_to_c_pointer                                               \
    ((char *(*)(PyObject *, CTypeDescrObject *))_cffi_exports[11])
#define _cffi_get_struct_layout                                          \
    not used any more
#define _cffi_restore_errno                                              \
    ((void(*)(void))_cffi_exports[13])
#define _cffi_save_errno                                                 \
    ((void(*)(void))_cffi_exports[14])
#define _cffi_from_c_char                                                \
    ((PyObject *(*)(char))_cffi_exports[15])
#define _cffi_from_c_deref                                               \
    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[16])
#define _cffi_to_c                                                       \
    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[17])
#define _cffi_from_c_struct                                              \
    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[18])
#define _cffi_to_c_wchar_t                                               \
    ((wchar_t(*)(PyObject *))_cffi_exports[19])
#define _cffi_from_c_wchar_t                                             \
    ((PyObject *(*)(wchar_t))_cffi_exports[20])
#define _cffi_to_c_long_double                                           \
    ((long double(*)(PyObject *))_cffi_exports[21])
#define _cffi_to_c__Bool                                                 \
    ((_Bool(*)(PyObject *))_cffi_exports[22])
#define _cffi_prepare_pointer_call_argument                              \
    ((Py_ssize_t(*)(CTypeDescrObject *, PyObject *, char **))_cffi_exports[23])
#define _cffi_convert_array_from_object                                  \
    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[24])
#define _CFFI_CPIDX  25
#define _cffi_call_python                                                \
    ((void(*)(struct _cffi_externpy_s *, char *))_cffi_exports[_CFFI_CPIDX])
#define _CFFI_NUM_EXPORTS 26

typedef struct _ctypedescr CTypeDescrObject;

static void *_cffi_exports[_CFFI_NUM_EXPORTS];

#define _cffi_type(index)   (                           \
    assert((((uintptr_t)_cffi_types[index]) & 1) == 0), \
    (CTypeDescrObject *)_cffi_types[index])

static PyObject *_cffi_init(const char *module_name, Py_ssize_t version,
                            const struct _cffi_type_context_s *ctx)
{
    PyObject *module, *o_arg, *new_module;
    void *raw[] = {
        (void *)module_name,
        (void *)version,
        (void *)_cffi_exports,
        (void *)ctx,
    };

    module = PyImport_ImportModule("_cffi_backend");
    if (module == NULL)
        goto failure;

    o_arg = PyLong_FromVoidPtr((void *)raw);
    if (o_arg == NULL)
        goto failure;

    new_module = PyObject_CallMethod(
        module, (char *)"_init_cffi_1_0_external_module", (char *)"O", o_arg);

    Py_DECREF(o_arg);
    Py_DECREF(module);
    return new_module;

  failure:
    Py_XDECREF(module);
    return NULL;
}

_CFFI_UNUSED_FN
static PyObject **_cffi_unpack_args(PyObject *args_tuple, Py_ssize_t expected,
                                    const char *fnname)
{
    if (PyTuple_GET_SIZE(args_tuple) != expected) {
        PyErr_Format(PyExc_TypeError,
                     "%.150s() takes exactly %zd arguments (%zd given)",
                     fnname, expected, PyTuple_GET_SIZE(args_tuple));
        return NULL;
    }
    return &PyTuple_GET_ITEM(args_tuple, 0);   /* pointer to the first item,
                                                  the others follow */
}

/**********  end CPython-specific section  **********/
#else
_CFFI_UNUSED_FN
static void (*_cffi_call_python_org)(struct _cffi_externpy_s *, char *);
# define _cffi_call_python  _cffi_call_python_org
#endif


#define _cffi_array_len(array)   (sizeof(array) / sizeof((array)[0]))

#define _cffi_prim_int(size, sign)                                      \
    ((size) == 1 ? ((sign) ? _CFFI_PRIM_INT8  : _CFFI_PRIM_UINT8)  :    \
     (size) == 2 ? ((sign) ? _CFFI_PRIM_INT16 : _CFFI_PRIM_UINT16) :    \
     (size) == 4 ? ((sign) ? _CFFI_PRIM_INT32 : _CFFI_PRIM_UINT32) :    \
     (size) == 8 ? ((sign) ? _CFFI_PRIM_INT64 : _CFFI_PRIM_UINT64) :    \
     _CFFI__UNKNOWN_PRIM)

#define _cffi_prim_float(size)                                          \
    ((size) == sizeof(float) ? _CFFI_PRIM_FLOAT :                       \
     (size) == sizeof(double) ? _CFFI_PRIM_DOUBLE :                     \
     (size) == sizeof(long double) ? _CFFI__UNKNOWN_LONG_DOUBLE :       \
     _CFFI__UNKNOWN_FLOAT_PRIM)

#define _cffi_check_int(got, got_nonpos, expected)      \
    ((got_nonpos) == (expected <= 0) &&                 \
     (got) == (unsigned long long)expected)

#ifdef MS_WIN32
# define _cffi_stdcall  __stdcall
#else
# define _cffi_stdcall  /* nothing */
#endif

#ifdef __cplusplus
}
#endif

/************************************************************/

/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// TODO(jeff,sanjay): Rename to tensorflow/public/c_api.h
#ifndef TENSORFLOW_PUBLIC_TENSOR_C_API_H_
#define TENSORFLOW_PUBLIC_TENSOR_C_API_H_

#include <stddef.h>

// --------------------------------------------------------------------------
// C API for TensorFlow.
//
// The API leans towards simplicity and uniformity instead of convenience
// since most usage will be by language specific wrappers.
//
// Conventions:
// * We use the prefix TF_ for everything in the API.
// * Objects are always passed around as pointers to opaque structs
//   and these structs are allocated/deallocated via the API.
// * TF_Status holds error information.  It is an object type
//   and therefore is passed around as a pointer to an opaque
//   struct as mentioned above.
// * Every call that has a TF_Status* argument clears it on success
//   and fills it with error info on failure.
//
// Questions left to address:
// * Might at some point need a way for callers to provide their own Env.
// * Should we remove the TF_Status arg from TF_AddProto calls and only
//   report errors later (e.g., on Run call).
// * Should dimensions be unsigned instead of signed?
// * Maybe add TF_TensorShape that encapsulates dimension info.
//
// Design decisions made:
// * Backing store for tensor memory has an associated deallocation
//   function.  This deallocation function will point to client code
//   for tensors populated by the client.  So the client can do things
//   like shadowing a numpy array.
// * We do not provide TF_OK since it is not strictly necessary and we
//   are not optimizing for convenience.
// * We make assumption that one session has one graph.  This should be
//   fine since we have the ability to run sub-graphs.
// * We are not providing TF_AddNode/TF_AddNodes to better support
//   languages/platforms where proto is not available.  This is because
//   we can just point authors of bindings at the .proto file and the
//   proto serialization spec and they can do the right thing for
//   their language.
// * We could allow NULL for some arguments (e.g., NULL options arg).
//   However since convenience is not a primary goal, we don't do this.
// * Devices are not in this API.  Instead, they are created/used internally
//   and the API just provides high level controls over the number of
//   devices of each type.

#ifdef __cplusplus
extern "C" {
#endif

// --------------------------------------------------------------------------
// TF_DataType holds the type for a scalar value.  E.g., one slot in a tensor.
// The enum values here are identical to corresponding values in types.proto.
typedef enum {
  TF_FLOAT = 1,
  TF_DOUBLE = 2,
  TF_INT32 = 3,  // Int32 tensors are always in 'host' memory.
  TF_UINT8 = 4,
  TF_INT16 = 5,
  TF_INT8 = 6,
  TF_STRING = 7,
  TF_COMPLEX64 = 8,  // Single-precision complex
  TF_COMPLEX = 8,    // Old identifier kept for API backwards compatibility
  TF_INT64 = 9,
  TF_BOOL = 10,
  TF_QINT8 = 11,     // Quantized int8
  TF_QUINT8 = 12,    // Quantized uint8
  TF_QINT32 = 13,    // Quantized int32
  TF_BFLOAT16 = 14,  // Float32 truncated to 16 bits.  Only for cast ops.
  TF_QINT16 = 15,    // Quantized int16
  TF_QUINT16 = 16,   // Quantized uint16
  TF_UINT16 = 17,
  TF_COMPLEX128 = 18,  // Double-precision complex
  TF_HALF = 19,
} TF_DataType;

// --------------------------------------------------------------------------
// TF_Code holds an error code.  The enum values here are identical to
// corresponding values in error_codes.proto.
typedef enum {
  TF_OK = 0,
  TF_CANCELLED = 1,
  TF_UNKNOWN = 2,
  TF_INVALID_ARGUMENT = 3,
  TF_DEADLINE_EXCEEDED = 4,
  TF_NOT_FOUND = 5,
  TF_ALREADY_EXISTS = 6,
  TF_PERMISSION_DENIED = 7,
  TF_UNAUTHENTICATED = 16,
  TF_RESOURCE_EXHAUSTED = 8,
  TF_FAILED_PRECONDITION = 9,
  TF_ABORTED = 10,
  TF_OUT_OF_RANGE = 11,
  TF_UNIMPLEMENTED = 12,
  TF_INTERNAL = 13,
  TF_UNAVAILABLE = 14,
  TF_DATA_LOSS = 15,
} TF_Code;

// --------------------------------------------------------------------------
// TF_Status holds error information.  It either has an OK code, or
// else an error code with an associated error message.
typedef struct TF_Status TF_Status;

// Return a new status object.
extern TF_Status* TF_NewStatus();

// Delete a previously created status object.
extern void TF_DeleteStatus(TF_Status*);

// Record <code, msg> in *s.  Any previous information is lost.
// A common use is to clear a status: TF_SetStatus(s, TF_OK, "");
extern void TF_SetStatus(TF_Status* s, TF_Code code, const char* msg);

// Return the code record in *s.
extern TF_Code TF_GetCode(const TF_Status* s);

// Return a pointer to the error message in *s.  The return value
// points to memory that is only usable until the next mutation to *s.
// Always returns an empty string if TF_GetCode(s) is TF_OK.
extern const char* TF_Message(const TF_Status* s);

// --------------------------------------------------------------------------
// TF_Buffer holds a pointer to a block of data and its associated length.
// Typically, the data consists of a serialized protocol buffer, but other data
// may also be held in a buffer.
//
// By default, TF_Buffer itself does not do any memory management of the
// pointed-to block.  If need be, users of this struct should specify how to
// deallocate the block by setting the `data_deallocator` function pointer.
typedef struct {
  const void* data;
  size_t length;
  void (*data_deallocator)(void* data, size_t length);
} TF_Buffer;

// Makes a copy of the input and sets an appropriate deallocator.  Useful for
// passing in read-only, input protobufs.
extern TF_Buffer* TF_NewBufferFromString(const void* proto, size_t proto_len);

// Useful for passing *out* a protobuf.
extern TF_Buffer* TF_NewBuffer();

extern void TF_DeleteBuffer(TF_Buffer*);

extern TF_Buffer TF_GetBuffer(TF_Buffer* buffer);

// --------------------------------------------------------------------------
// TF_Tensor holds a multi-dimensional array of elements of a single data type.
// For all types other than TF_STRING, the data buffer stores elements
// in row major order.  E.g. if data is treated as a vector of TF_DataType:
//
//   element 0:   index (0, ..., 0)
//   element 1:   index (0, ..., 1)
//   ...
//
// The format for TF_STRING tensors is:
//   start_offset: array[uint64]
//   data:         byte[...]
//
//   String length is encoded (varint?) starting at data[start_offset[i]]
//   String contents follow immediately after string length.

typedef struct TF_Tensor TF_Tensor;

// Return a new tensor that holds the bytes data[0,len-1].
//
// The data will be deallocated by a subsequent call to TF_DeleteTensor via:
//      (*deallocator)(data, len, deallocator_arg)
// Clients must provide a custom deallocator function so they can pass in
// memory managed by something like numpy.
extern TF_Tensor* TF_NewTensor(TF_DataType, const long long* dims, int num_dims,
                               void* data, size_t len,
                               void (*deallocator)(void* data, size_t len,
                                                   void* arg),
                               void* deallocator_arg);

// Destroy a tensor.
extern void TF_DeleteTensor(TF_Tensor*);

// Return the type of a tensor element.
extern TF_DataType TF_TensorType(const TF_Tensor*);

// Return the number of dimensions that the tensor has.
extern int TF_NumDims(const TF_Tensor*);

// Return the length of the tensor in the "dim_index" dimension.
// REQUIRES: 0 <= dim_index < TF_NumDims(tensor)
extern long long TF_Dim(const TF_Tensor* tensor, int dim_index);

// Return the size of the underlying data in bytes.
extern size_t TF_TensorByteSize(const TF_Tensor*);

// Return a pointer to the underlying data buffer.
extern void* TF_TensorData(const TF_Tensor*);

// --------------------------------------------------------------------------
// TF_SessionOptions holds options that can be passed during session creation.
typedef struct TF_SessionOptions TF_SessionOptions;

// Return a new options object.
extern TF_SessionOptions* TF_NewSessionOptions();

// Set the target in TF_SessionOptions.options.
// target can be empty, a single entry, or a comma separated list of entries.
// Each entry is in one of the following formats :
// "local"
// ip:port
// host:port
extern void TF_SetTarget(TF_SessionOptions* options, const char* target);

// Set the config in TF_SessionOptions.options.
// config should be a serialized brain.ConfigProto proto.
// If config was not parsed successfully as a ConfigProto, record the
// error information in *status.
extern void TF_SetConfig(TF_SessionOptions* options, const void* proto,
                         size_t proto_len, TF_Status* status);

// Destroy an options object.
extern void TF_DeleteSessionOptions(TF_SessionOptions*);

// TODO(jeff,sanjay):
// - export functions to set Config fields

// --------------------------------------------------------------------------
// TF_Session manages a single graph and execution.
typedef struct TF_Session TF_Session;

// Return a new execution session, or NULL on error.
extern TF_Session* TF_NewSession(const TF_SessionOptions*, TF_Status* status);

// Close a session.
extern void TF_CloseSession(TF_Session*, TF_Status* status);

// Destroy a session.  Even if error information is recorded in *status,
// this call discards all resources associated with the session.
extern void TF_DeleteSession(TF_Session*, TF_Status* status);

// Closes all existing sessions connected to the `target` specified in the
// `SessionOptions`, and frees shared resources in `containers` on `target'.
// If no containers are provided, all containers are cleared.
extern void TF_Reset(const TF_SessionOptions* opt, const char** containers,
                     int ncontainers, TF_Status* status);

// Treat the bytes proto[0,proto_len-1] as a serialized GraphDef and
// add the nodes in that GraphDef to the graph for the session.
extern void TF_ExtendGraph(TF_Session*, const void* proto, size_t proto_len,
                           TF_Status*);

// Run the graph associated with the session starting with the
// supplied inputs (inputs[0,ninputs-1]).  Regardless of success or
// failure, inputs[] become the property of the implementation (the
// implementation will eventually call TF_DeleteTensor on each input).
//
// Any NULL and non-NULL value combinations for (`run_options`,
// `run_metadata`) are valid.
//
//    - `run_options` may be NULL, in which case it will be ignored; or
//      non-NULL, in which case it must point to a `TF_Buffer` containing the
//      serialized representation of a `RunOptions` protocol buffer.
//    - `run_metadata` may be NULL, in which case it will be ignored; or
//      non-NULL, in which case it must point to an empty, freshly allocated
//      `TF_Buffer` that may be updated to contain the serialized representation
//      of a `RunMetadata` protocol buffer.
//
// The caller retains the ownership of `run_options` and/or `run_metadata` (when
// not NULL) and should manually call TF_DeleteBuffer on them.
//
// On success, the tensors corresponding to output_names[0,noutputs-1]
// are placed in outputs[], and these outputs[] become the property
// of the caller (the caller must eventually call TF_DeleteTensor on
// them).
//
// On failure, outputs[] contains NULLs.
extern void TF_Run(TF_Session*,
                   // RunOptions
                   const TF_Buffer* run_options,
                   // Input tensors
                   const char** input_names, TF_Tensor** inputs, int ninputs,
                   // Output tensors
                   const char** output_tensor_names, TF_Tensor** outputs,
                   int noutputs,
                   // Target nodes
                   const char** target_node_names, int ntargets,
                   // RunMetadata
                   TF_Buffer* run_metadata,
                   // Output status
                   TF_Status*);

// Set up the graph with the intended feeds and fetches for a sequence
// of partial run calls.
//
// On success, returns a handle that is used for subsequent PRun calls.
//
// On failure, out_status contains a tensorflow::Status with an error
// message.
// NOTE: This is EXPERIMENTAL and subject to change.
extern void TF_PRunSetup(TF_Session*,
                         // Input names
                         const char** input_names, int ninputs,
                         // Output names
                         const char** output_tensor_names, int noutputs,
                         // Target nodes
                         const char** target_node_names, int ntargets,
                         // Output handle
                         char** handle,
                         // Output status
                         TF_Status*);

// Continue to run the graph with additional feeds and fetches. The
// execution state is uniquely identified by the handle.
// NOTE: This is EXPERIMENTAL and subject to change.
extern void TF_PRun(TF_Session*, const char* handle,
                    // Input tensors
                    const char** input_names, TF_Tensor** inputs, int ninputs,
                    // Output tensors
                    const char** output_tensor_names, TF_Tensor** outputs,
                    int noutputs,
                    // Target nodes
                    const char** target_node_names, int ntargets,
                    // Output status
                    TF_Status*);

// --------------------------------------------------------------------------
// Load plugins containing custom ops and kernels

// TF_Library holds information about dynamically loaded TensorFlow plugins.
typedef struct TF_Library TF_Library;

// Load the library specified by library_filename and register the ops and
// kernels present in that library.
//
// Pass "library_filename" to a platform-specific mechanism for dynamically
// loading a library. The rules for determining the exact location of the
// library are platform-specific and are not documented here.
// Expects the symbols "RegisterOps", "RegisterKernels", and "GetOpList", to be
// defined in the library.
//
// On success, place OK in status and return the newly created library handle.
// The caller owns the library handle.
//
// On failure, place an error status in status and return NULL.
extern TF_Library* TF_LoadLibrary(const char* library_filename,
                                  TF_Status* status);

// Get the OpList of OpDefs defined in the library pointed by lib_handle.
//
// Returns a TF_Buffer. The memory pointed to by the result is owned by
// lib_handle. The data in the buffer will be the serialized OpList proto for
// ops defined in the library.
extern TF_Buffer TF_GetOpList(TF_Library* lib_handle);

#ifdef __cplusplus
} /* end extern "C" */
#endif

#endif  // TENSORFLOW_PUBLIC_TENSOR_C_API_H_


/************************************************************/

static void *_cffi_types[] = {
/*  0 */ _CFFI_OP(_CFFI_OP_FUNCTION, 7), // TF_Buffer *()(void const *, size_t)
/*  1 */ _CFFI_OP(_CFFI_OP_POINTER, 155), // void const *
/*  2 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28), // size_t
/*  3 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  4 */ _CFFI_OP(_CFFI_OP_FUNCTION, 7), // TF_Buffer *()(void)
/*  5 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  6 */ _CFFI_OP(_CFFI_OP_FUNCTION, 145), // TF_Buffer()(TF_Buffer *)
/*  7 */ _CFFI_OP(_CFFI_OP_POINTER, 145), // TF_Buffer *
/*  8 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/*  9 */ _CFFI_OP(_CFFI_OP_FUNCTION, 145), // TF_Buffer()(TF_Library *)
/* 10 */ _CFFI_OP(_CFFI_OP_POINTER, 146), // TF_Library *
/* 11 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 12 */ _CFFI_OP(_CFFI_OP_FUNCTION, 130), // TF_Code()(TF_Status const *)
/* 13 */ _CFFI_OP(_CFFI_OP_POINTER, 149), // TF_Status const *
/* 14 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 15 */ _CFFI_OP(_CFFI_OP_FUNCTION, 31), // TF_DataType()(TF_Tensor const *)
/* 16 */ _CFFI_OP(_CFFI_OP_POINTER, 150), // TF_Tensor const *
/* 17 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 18 */ _CFFI_OP(_CFFI_OP_FUNCTION, 10), // TF_Library *()(char const *, TF_Status *)
/* 19 */ _CFFI_OP(_CFFI_OP_POINTER, 152), // char const *
/* 20 */ _CFFI_OP(_CFFI_OP_POINTER, 149), // TF_Status *
/* 21 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 22 */ _CFFI_OP(_CFFI_OP_FUNCTION, 59), // TF_Session *()(TF_SessionOptions const *, TF_Status *)
/* 23 */ _CFFI_OP(_CFFI_OP_POINTER, 148), // TF_SessionOptions const *
/* 24 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 25 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 26 */ _CFFI_OP(_CFFI_OP_FUNCTION, 107), // TF_SessionOptions *()(void)
/* 27 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 28 */ _CFFI_OP(_CFFI_OP_FUNCTION, 20), // TF_Status *()(void)
/* 29 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 30 */ _CFFI_OP(_CFFI_OP_FUNCTION, 134), // TF_Tensor *()(TF_DataType, long long const *, int, void *, size_t, void(*)(void *, size_t, void *), void *)
/* 31 */ _CFFI_OP(_CFFI_OP_ENUM, 1), // TF_DataType
/* 32 */ _CFFI_OP(_CFFI_OP_POINTER, 153), // long long const *
/* 33 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7), // int
/* 34 */ _CFFI_OP(_CFFI_OP_POINTER, 155), // void *
/* 35 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 36 */ _CFFI_OP(_CFFI_OP_POINTER, 140), // void(*)(void *, size_t, void *)
/* 37 */ _CFFI_OP(_CFFI_OP_NOOP, 34),
/* 38 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 39 */ _CFFI_OP(_CFFI_OP_FUNCTION, 19), // char const *()(TF_Status const *)
/* 40 */ _CFFI_OP(_CFFI_OP_NOOP, 13),
/* 41 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 42 */ _CFFI_OP(_CFFI_OP_FUNCTION, 33), // int()(TF_Tensor const *)
/* 43 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 44 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 45 */ _CFFI_OP(_CFFI_OP_FUNCTION, 153), // long long()(TF_Tensor const *, int)
/* 46 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 47 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 48 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 49 */ _CFFI_OP(_CFFI_OP_FUNCTION, 2), // size_t()(TF_Tensor const *)
/* 50 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 51 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 52 */ _CFFI_OP(_CFFI_OP_FUNCTION, 34), // void *()(TF_Tensor const *)
/* 53 */ _CFFI_OP(_CFFI_OP_NOOP, 16),
/* 54 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 55 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(TF_Buffer *)
/* 56 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 57 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 58 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(TF_Session *, TF_Buffer const *, char const * *, TF_Tensor * *, int, char const * *, TF_Tensor * *, int, char const * *, int, TF_Buffer *, TF_Status *)
/* 59 */ _CFFI_OP(_CFFI_OP_POINTER, 147), // TF_Session *
/* 60 */ _CFFI_OP(_CFFI_OP_POINTER, 145), // TF_Buffer const *
/* 61 */ _CFFI_OP(_CFFI_OP_POINTER, 19), // char const * *
/* 62 */ _CFFI_OP(_CFFI_OP_POINTER, 134), // TF_Tensor * *
/* 63 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 64 */ _CFFI_OP(_CFFI_OP_NOOP, 61),
/* 65 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 66 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 67 */ _CFFI_OP(_CFFI_OP_NOOP, 61),
/* 68 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 69 */ _CFFI_OP(_CFFI_OP_NOOP, 7),
/* 70 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 71 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 72 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(TF_Session *, TF_Status *)
/* 73 */ _CFFI_OP(_CFFI_OP_NOOP, 59),
/* 74 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 75 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 76 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(TF_Session *, char const * *, int, char const * *, int, char const * *, int, char * *, TF_Status *)
/* 77 */ _CFFI_OP(_CFFI_OP_NOOP, 59),
/* 78 */ _CFFI_OP(_CFFI_OP_NOOP, 61),
/* 79 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 80 */ _CFFI_OP(_CFFI_OP_NOOP, 61),
/* 81 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 82 */ _CFFI_OP(_CFFI_OP_NOOP, 61),
/* 83 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 84 */ _CFFI_OP(_CFFI_OP_POINTER, 151), // char * *
/* 85 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 86 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 87 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(TF_Session *, char const *, char const * *, TF_Tensor * *, int, char const * *, TF_Tensor * *, int, char const * *, int, TF_Status *)
/* 88 */ _CFFI_OP(_CFFI_OP_NOOP, 59),
/* 89 */ _CFFI_OP(_CFFI_OP_NOOP, 19),
/* 90 */ _CFFI_OP(_CFFI_OP_NOOP, 61),
/* 91 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 92 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 93 */ _CFFI_OP(_CFFI_OP_NOOP, 61),
/* 94 */ _CFFI_OP(_CFFI_OP_NOOP, 62),
/* 95 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 96 */ _CFFI_OP(_CFFI_OP_NOOP, 61),
/* 97 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 98 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 99 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 100 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(TF_Session *, void const *, size_t, TF_Status *)
/* 101 */ _CFFI_OP(_CFFI_OP_NOOP, 59),
/* 102 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 103 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 104 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 105 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 106 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(TF_SessionOptions *)
/* 107 */ _CFFI_OP(_CFFI_OP_POINTER, 148), // TF_SessionOptions *
/* 108 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 109 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(TF_SessionOptions *, char const *)
/* 110 */ _CFFI_OP(_CFFI_OP_NOOP, 107),
/* 111 */ _CFFI_OP(_CFFI_OP_NOOP, 19),
/* 112 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 113 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(TF_SessionOptions *, void const *, size_t, TF_Status *)
/* 114 */ _CFFI_OP(_CFFI_OP_NOOP, 107),
/* 115 */ _CFFI_OP(_CFFI_OP_NOOP, 1),
/* 116 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 117 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 118 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 119 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(TF_SessionOptions const *, char const * *, int, TF_Status *)
/* 120 */ _CFFI_OP(_CFFI_OP_NOOP, 23),
/* 121 */ _CFFI_OP(_CFFI_OP_NOOP, 61),
/* 122 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 7),
/* 123 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 124 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 125 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(TF_Status *)
/* 126 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 127 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 128 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(TF_Status *, TF_Code, char const *)
/* 129 */ _CFFI_OP(_CFFI_OP_NOOP, 20),
/* 130 */ _CFFI_OP(_CFFI_OP_ENUM, 0), // TF_Code
/* 131 */ _CFFI_OP(_CFFI_OP_NOOP, 19),
/* 132 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 133 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(TF_Tensor *)
/* 134 */ _CFFI_OP(_CFFI_OP_POINTER, 150), // TF_Tensor *
/* 135 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 136 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(void *, size_t)
/* 137 */ _CFFI_OP(_CFFI_OP_NOOP, 34),
/* 138 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 139 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 140 */ _CFFI_OP(_CFFI_OP_FUNCTION, 155), // void()(void *, size_t, void *)
/* 141 */ _CFFI_OP(_CFFI_OP_NOOP, 34),
/* 142 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 28),
/* 143 */ _CFFI_OP(_CFFI_OP_NOOP, 34),
/* 144 */ _CFFI_OP(_CFFI_OP_FUNCTION_END, 0),
/* 145 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 0), // TF_Buffer
/* 146 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 1), // TF_Library
/* 147 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 2), // TF_Session
/* 148 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 3), // TF_SessionOptions
/* 149 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 4), // TF_Status
/* 150 */ _CFFI_OP(_CFFI_OP_STRUCT_UNION, 5), // TF_Tensor
/* 151 */ _CFFI_OP(_CFFI_OP_POINTER, 152), // char *
/* 152 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 2), // char
/* 153 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 11), // long long
/* 154 */ _CFFI_OP(_CFFI_OP_POINTER, 136), // void(*)(void *, size_t)
/* 155 */ _CFFI_OP(_CFFI_OP_PRIMITIVE, 0), // void
};

_CFFI_UNUSED_FN
static void _cffi_checkfld_typedef_TF_Buffer(TF_Buffer *p)
{
  /* only to generate compile-time warnings or errors */
  (void)p;
  { void const * *tmp = &p->data; (void)tmp; }
  (void)((p->length) | 0);  /* check that 'TF_Buffer.length' is an integer */
  { void(* *tmp)(void *, size_t) = &p->data_deallocator; (void)tmp; }
}
struct _cffi_align_typedef_TF_Buffer { char x; TF_Buffer y; };

static int _cffi_const_TF_OK(unsigned long long *o)
{
  int n = (TF_OK) <= 0;
  *o = (unsigned long long)((TF_OK) | 0);  /* check that TF_OK is an integer */
  return n;
}

static int _cffi_const_TF_CANCELLED(unsigned long long *o)
{
  int n = (TF_CANCELLED) <= 0;
  *o = (unsigned long long)((TF_CANCELLED) | 0);  /* check that TF_CANCELLED is an integer */
  return n;
}

static int _cffi_const_TF_UNKNOWN(unsigned long long *o)
{
  int n = (TF_UNKNOWN) <= 0;
  *o = (unsigned long long)((TF_UNKNOWN) | 0);  /* check that TF_UNKNOWN is an integer */
  return n;
}

static int _cffi_const_TF_INVALID_ARGUMENT(unsigned long long *o)
{
  int n = (TF_INVALID_ARGUMENT) <= 0;
  *o = (unsigned long long)((TF_INVALID_ARGUMENT) | 0);  /* check that TF_INVALID_ARGUMENT is an integer */
  return n;
}

static int _cffi_const_TF_DEADLINE_EXCEEDED(unsigned long long *o)
{
  int n = (TF_DEADLINE_EXCEEDED) <= 0;
  *o = (unsigned long long)((TF_DEADLINE_EXCEEDED) | 0);  /* check that TF_DEADLINE_EXCEEDED is an integer */
  return n;
}

static int _cffi_const_TF_NOT_FOUND(unsigned long long *o)
{
  int n = (TF_NOT_FOUND) <= 0;
  *o = (unsigned long long)((TF_NOT_FOUND) | 0);  /* check that TF_NOT_FOUND is an integer */
  return n;
}

static int _cffi_const_TF_ALREADY_EXISTS(unsigned long long *o)
{
  int n = (TF_ALREADY_EXISTS) <= 0;
  *o = (unsigned long long)((TF_ALREADY_EXISTS) | 0);  /* check that TF_ALREADY_EXISTS is an integer */
  return n;
}

static int _cffi_const_TF_PERMISSION_DENIED(unsigned long long *o)
{
  int n = (TF_PERMISSION_DENIED) <= 0;
  *o = (unsigned long long)((TF_PERMISSION_DENIED) | 0);  /* check that TF_PERMISSION_DENIED is an integer */
  return n;
}

static int _cffi_const_TF_UNAUTHENTICATED(unsigned long long *o)
{
  int n = (TF_UNAUTHENTICATED) <= 0;
  *o = (unsigned long long)((TF_UNAUTHENTICATED) | 0);  /* check that TF_UNAUTHENTICATED is an integer */
  return n;
}

static int _cffi_const_TF_RESOURCE_EXHAUSTED(unsigned long long *o)
{
  int n = (TF_RESOURCE_EXHAUSTED) <= 0;
  *o = (unsigned long long)((TF_RESOURCE_EXHAUSTED) | 0);  /* check that TF_RESOURCE_EXHAUSTED is an integer */
  return n;
}

static int _cffi_const_TF_FAILED_PRECONDITION(unsigned long long *o)
{
  int n = (TF_FAILED_PRECONDITION) <= 0;
  *o = (unsigned long long)((TF_FAILED_PRECONDITION) | 0);  /* check that TF_FAILED_PRECONDITION is an integer */
  return n;
}

static int _cffi_const_TF_ABORTED(unsigned long long *o)
{
  int n = (TF_ABORTED) <= 0;
  *o = (unsigned long long)((TF_ABORTED) | 0);  /* check that TF_ABORTED is an integer */
  return n;
}

static int _cffi_const_TF_OUT_OF_RANGE(unsigned long long *o)
{
  int n = (TF_OUT_OF_RANGE) <= 0;
  *o = (unsigned long long)((TF_OUT_OF_RANGE) | 0);  /* check that TF_OUT_OF_RANGE is an integer */
  return n;
}

static int _cffi_const_TF_UNIMPLEMENTED(unsigned long long *o)
{
  int n = (TF_UNIMPLEMENTED) <= 0;
  *o = (unsigned long long)((TF_UNIMPLEMENTED) | 0);  /* check that TF_UNIMPLEMENTED is an integer */
  return n;
}

static int _cffi_const_TF_INTERNAL(unsigned long long *o)
{
  int n = (TF_INTERNAL) <= 0;
  *o = (unsigned long long)((TF_INTERNAL) | 0);  /* check that TF_INTERNAL is an integer */
  return n;
}

static int _cffi_const_TF_UNAVAILABLE(unsigned long long *o)
{
  int n = (TF_UNAVAILABLE) <= 0;
  *o = (unsigned long long)((TF_UNAVAILABLE) | 0);  /* check that TF_UNAVAILABLE is an integer */
  return n;
}

static int _cffi_const_TF_DATA_LOSS(unsigned long long *o)
{
  int n = (TF_DATA_LOSS) <= 0;
  *o = (unsigned long long)((TF_DATA_LOSS) | 0);  /* check that TF_DATA_LOSS is an integer */
  return n;
}

static int _cffi_const_TF_FLOAT(unsigned long long *o)
{
  int n = (TF_FLOAT) <= 0;
  *o = (unsigned long long)((TF_FLOAT) | 0);  /* check that TF_FLOAT is an integer */
  return n;
}

static int _cffi_const_TF_DOUBLE(unsigned long long *o)
{
  int n = (TF_DOUBLE) <= 0;
  *o = (unsigned long long)((TF_DOUBLE) | 0);  /* check that TF_DOUBLE is an integer */
  return n;
}

static int _cffi_const_TF_INT32(unsigned long long *o)
{
  int n = (TF_INT32) <= 0;
  *o = (unsigned long long)((TF_INT32) | 0);  /* check that TF_INT32 is an integer */
  return n;
}

static int _cffi_const_TF_UINT8(unsigned long long *o)
{
  int n = (TF_UINT8) <= 0;
  *o = (unsigned long long)((TF_UINT8) | 0);  /* check that TF_UINT8 is an integer */
  return n;
}

static int _cffi_const_TF_INT16(unsigned long long *o)
{
  int n = (TF_INT16) <= 0;
  *o = (unsigned long long)((TF_INT16) | 0);  /* check that TF_INT16 is an integer */
  return n;
}

static int _cffi_const_TF_INT8(unsigned long long *o)
{
  int n = (TF_INT8) <= 0;
  *o = (unsigned long long)((TF_INT8) | 0);  /* check that TF_INT8 is an integer */
  return n;
}

static int _cffi_const_TF_STRING(unsigned long long *o)
{
  int n = (TF_STRING) <= 0;
  *o = (unsigned long long)((TF_STRING) | 0);  /* check that TF_STRING is an integer */
  return n;
}

static int _cffi_const_TF_COMPLEX64(unsigned long long *o)
{
  int n = (TF_COMPLEX64) <= 0;
  *o = (unsigned long long)((TF_COMPLEX64) | 0);  /* check that TF_COMPLEX64 is an integer */
  return n;
}

static int _cffi_const_TF_COMPLEX(unsigned long long *o)
{
  int n = (TF_COMPLEX) <= 0;
  *o = (unsigned long long)((TF_COMPLEX) | 0);  /* check that TF_COMPLEX is an integer */
  return n;
}

static int _cffi_const_TF_INT64(unsigned long long *o)
{
  int n = (TF_INT64) <= 0;
  *o = (unsigned long long)((TF_INT64) | 0);  /* check that TF_INT64 is an integer */
  return n;
}

static int _cffi_const_TF_BOOL(unsigned long long *o)
{
  int n = (TF_BOOL) <= 0;
  *o = (unsigned long long)((TF_BOOL) | 0);  /* check that TF_BOOL is an integer */
  return n;
}

static int _cffi_const_TF_QINT8(unsigned long long *o)
{
  int n = (TF_QINT8) <= 0;
  *o = (unsigned long long)((TF_QINT8) | 0);  /* check that TF_QINT8 is an integer */
  return n;
}

static int _cffi_const_TF_QUINT8(unsigned long long *o)
{
  int n = (TF_QUINT8) <= 0;
  *o = (unsigned long long)((TF_QUINT8) | 0);  /* check that TF_QUINT8 is an integer */
  return n;
}

static int _cffi_const_TF_QINT32(unsigned long long *o)
{
  int n = (TF_QINT32) <= 0;
  *o = (unsigned long long)((TF_QINT32) | 0);  /* check that TF_QINT32 is an integer */
  return n;
}

static int _cffi_const_TF_BFLOAT16(unsigned long long *o)
{
  int n = (TF_BFLOAT16) <= 0;
  *o = (unsigned long long)((TF_BFLOAT16) | 0);  /* check that TF_BFLOAT16 is an integer */
  return n;
}

static int _cffi_const_TF_QINT16(unsigned long long *o)
{
  int n = (TF_QINT16) <= 0;
  *o = (unsigned long long)((TF_QINT16) | 0);  /* check that TF_QINT16 is an integer */
  return n;
}

static int _cffi_const_TF_QUINT16(unsigned long long *o)
{
  int n = (TF_QUINT16) <= 0;
  *o = (unsigned long long)((TF_QUINT16) | 0);  /* check that TF_QUINT16 is an integer */
  return n;
}

static int _cffi_const_TF_UINT16(unsigned long long *o)
{
  int n = (TF_UINT16) <= 0;
  *o = (unsigned long long)((TF_UINT16) | 0);  /* check that TF_UINT16 is an integer */
  return n;
}

static int _cffi_const_TF_COMPLEX128(unsigned long long *o)
{
  int n = (TF_COMPLEX128) <= 0;
  *o = (unsigned long long)((TF_COMPLEX128) | 0);  /* check that TF_COMPLEX128 is an integer */
  return n;
}

static int _cffi_const_TF_HALF(unsigned long long *o)
{
  int n = (TF_HALF) <= 0;
  *o = (unsigned long long)((TF_HALF) | 0);  /* check that TF_HALF is an integer */
  return n;
}

static void _cffi_d_TF_CloseSession(TF_Session * x0, TF_Status * x1)
{
  TF_CloseSession(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_CloseSession(PyObject *self, PyObject *args)
{
  TF_Session * x0;
  TF_Status * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 2, "TF_CloseSession");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(59), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Session *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(59), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (TF_Status *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_CloseSession(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_CloseSession _cffi_d_TF_CloseSession
#endif

static void _cffi_d_TF_DeleteBuffer(TF_Buffer * x0)
{
  TF_DeleteBuffer(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_DeleteBuffer(PyObject *self, PyObject *arg0)
{
  TF_Buffer * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Buffer *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(7), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_DeleteBuffer(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_DeleteBuffer _cffi_d_TF_DeleteBuffer
#endif

static void _cffi_d_TF_DeleteSession(TF_Session * x0, TF_Status * x1)
{
  TF_DeleteSession(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_DeleteSession(PyObject *self, PyObject *args)
{
  TF_Session * x0;
  TF_Status * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 2, "TF_DeleteSession");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(59), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Session *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(59), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (TF_Status *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_DeleteSession(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_DeleteSession _cffi_d_TF_DeleteSession
#endif

static void _cffi_d_TF_DeleteSessionOptions(TF_SessionOptions * x0)
{
  TF_DeleteSessionOptions(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_DeleteSessionOptions(PyObject *self, PyObject *arg0)
{
  TF_SessionOptions * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(107), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_SessionOptions *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(107), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_DeleteSessionOptions(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_DeleteSessionOptions _cffi_d_TF_DeleteSessionOptions
#endif

static void _cffi_d_TF_DeleteStatus(TF_Status * x0)
{
  TF_DeleteStatus(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_DeleteStatus(PyObject *self, PyObject *arg0)
{
  TF_Status * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Status *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_DeleteStatus(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_DeleteStatus _cffi_d_TF_DeleteStatus
#endif

static void _cffi_d_TF_DeleteTensor(TF_Tensor * x0)
{
  TF_DeleteTensor(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_DeleteTensor(PyObject *self, PyObject *arg0)
{
  TF_Tensor * x0;
  Py_ssize_t datasize;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(134), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Tensor *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(134), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_DeleteTensor(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_DeleteTensor _cffi_d_TF_DeleteTensor
#endif

static long long _cffi_d_TF_Dim(TF_Tensor const * x0, int x1)
{
  return TF_Dim(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_Dim(PyObject *self, PyObject *args)
{
  TF_Tensor const * x0;
  int x1;
  Py_ssize_t datasize;
  long long result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 2, "TF_Dim");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Tensor const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(16), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, int);
  if (x1 == (int)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_Dim(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, long long);
}
#else
#  define _cffi_f_TF_Dim _cffi_d_TF_Dim
#endif

static void _cffi_d_TF_ExtendGraph(TF_Session * x0, void const * x1, size_t x2, TF_Status * x3)
{
  TF_ExtendGraph(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_ExtendGraph(PyObject *self, PyObject *args)
{
  TF_Session * x0;
  void const * x1;
  size_t x2;
  TF_Status * x3;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 4, "TF_ExtendGraph");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];
  arg2 = aa[2];
  arg3 = aa[3];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(59), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Session *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(59), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (TF_Status *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(20), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_ExtendGraph(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_ExtendGraph _cffi_d_TF_ExtendGraph
#endif

static TF_Buffer _cffi_d_TF_GetBuffer(TF_Buffer * x0)
{
  return TF_GetBuffer(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_GetBuffer(PyObject *self, PyObject *arg0)
{
  TF_Buffer * x0;
  Py_ssize_t datasize;
  TF_Buffer result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Buffer *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(7), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_GetBuffer(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(145));
}
#else
static void _cffi_f_TF_GetBuffer(TF_Buffer *result, TF_Buffer * x0)
{
  { *result = TF_GetBuffer(x0); }
}
#endif

static TF_Code _cffi_d_TF_GetCode(TF_Status const * x0)
{
  return TF_GetCode(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_GetCode(PyObject *self, PyObject *arg0)
{
  TF_Status const * x0;
  Py_ssize_t datasize;
  TF_Code result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Status const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_GetCode(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_deref((char *)&result, _cffi_type(130));
}
#else
#  define _cffi_f_TF_GetCode _cffi_d_TF_GetCode
#endif

static TF_Buffer _cffi_d_TF_GetOpList(TF_Library * x0)
{
  return TF_GetOpList(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_GetOpList(PyObject *self, PyObject *arg0)
{
  TF_Library * x0;
  Py_ssize_t datasize;
  TF_Buffer result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(10), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Library *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(10), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_GetOpList(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_struct((char *)&result, _cffi_type(145));
}
#else
static void _cffi_f_TF_GetOpList(TF_Buffer *result, TF_Library * x0)
{
  { *result = TF_GetOpList(x0); }
}
#endif

static TF_Library * _cffi_d_TF_LoadLibrary(char const * x0, TF_Status * x1)
{
  return TF_LoadLibrary(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_LoadLibrary(PyObject *self, PyObject *args)
{
  char const * x0;
  TF_Status * x1;
  Py_ssize_t datasize;
  TF_Library * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 2, "TF_LoadLibrary");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(19), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (char const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(19), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (TF_Status *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_LoadLibrary(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(10));
}
#else
#  define _cffi_f_TF_LoadLibrary _cffi_d_TF_LoadLibrary
#endif

static char const * _cffi_d_TF_Message(TF_Status const * x0)
{
  return TF_Message(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_Message(PyObject *self, PyObject *arg0)
{
  TF_Status const * x0;
  Py_ssize_t datasize;
  char const * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(13), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Status const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(13), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_Message(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(19));
}
#else
#  define _cffi_f_TF_Message _cffi_d_TF_Message
#endif

static TF_Buffer * _cffi_d_TF_NewBuffer(void)
{
  return TF_NewBuffer();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_NewBuffer(PyObject *self, PyObject *noarg)
{
  TF_Buffer * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_NewBuffer(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(7));
}
#else
#  define _cffi_f_TF_NewBuffer _cffi_d_TF_NewBuffer
#endif

static TF_Buffer * _cffi_d_TF_NewBufferFromString(void const * x0, size_t x1)
{
  return TF_NewBufferFromString(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_NewBufferFromString(PyObject *self, PyObject *args)
{
  void const * x0;
  size_t x1;
  Py_ssize_t datasize;
  TF_Buffer * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 2, "TF_NewBufferFromString");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (void const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(1), arg0) < 0)
      return NULL;
  }

  x1 = _cffi_to_c_int(arg1, size_t);
  if (x1 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_NewBufferFromString(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(7));
}
#else
#  define _cffi_f_TF_NewBufferFromString _cffi_d_TF_NewBufferFromString
#endif

static TF_Session * _cffi_d_TF_NewSession(TF_SessionOptions const * x0, TF_Status * x1)
{
  return TF_NewSession(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_NewSession(PyObject *self, PyObject *args)
{
  TF_SessionOptions const * x0;
  TF_Status * x1;
  Py_ssize_t datasize;
  TF_Session * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 2, "TF_NewSession");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_SessionOptions const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(23), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (TF_Status *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(20), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_NewSession(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(59));
}
#else
#  define _cffi_f_TF_NewSession _cffi_d_TF_NewSession
#endif

static TF_SessionOptions * _cffi_d_TF_NewSessionOptions(void)
{
  return TF_NewSessionOptions();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_NewSessionOptions(PyObject *self, PyObject *noarg)
{
  TF_SessionOptions * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_NewSessionOptions(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(107));
}
#else
#  define _cffi_f_TF_NewSessionOptions _cffi_d_TF_NewSessionOptions
#endif

static TF_Status * _cffi_d_TF_NewStatus(void)
{
  return TF_NewStatus();
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_NewStatus(PyObject *self, PyObject *noarg)
{
  TF_Status * result;

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_NewStatus(); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  (void)noarg; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(20));
}
#else
#  define _cffi_f_TF_NewStatus _cffi_d_TF_NewStatus
#endif

static TF_Tensor * _cffi_d_TF_NewTensor(TF_DataType x0, long long const * x1, int x2, void * x3, size_t x4, void(* x5)(void *, size_t, void *), void * x6)
{
  return TF_NewTensor(x0, x1, x2, x3, x4, x5, x6);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_NewTensor(PyObject *self, PyObject *args)
{
  TF_DataType x0;
  long long const * x1;
  int x2;
  void * x3;
  size_t x4;
  void(* x5)(void *, size_t, void *);
  void * x6;
  Py_ssize_t datasize;
  TF_Tensor * result;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 7, "TF_NewTensor");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];
  arg2 = aa[2];
  arg3 = aa[3];
  arg4 = aa[4];
  arg5 = aa[5];
  arg6 = aa[6];

  if (_cffi_to_c((char *)&x0, _cffi_type(31), arg0) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(32), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (long long const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(32), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(34), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (void *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(34), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, size_t);
  if (x4 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  x5 = (void(*)(void *, size_t, void *))_cffi_to_c_pointer(arg5, _cffi_type(36));
  if (x5 == (void(*)(void *, size_t, void *))NULL && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(34), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (void *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(34), arg6) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_NewTensor(x0, x1, x2, x3, x4, x5, x6); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(134));
}
#else
#  define _cffi_f_TF_NewTensor _cffi_d_TF_NewTensor
#endif

static int _cffi_d_TF_NumDims(TF_Tensor const * x0)
{
  return TF_NumDims(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_NumDims(PyObject *self, PyObject *arg0)
{
  TF_Tensor const * x0;
  Py_ssize_t datasize;
  int result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Tensor const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(16), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_NumDims(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, int);
}
#else
#  define _cffi_f_TF_NumDims _cffi_d_TF_NumDims
#endif

static void _cffi_d_TF_PRun(TF_Session * x0, char const * x1, char const * * x2, TF_Tensor * * x3, int x4, char const * * x5, TF_Tensor * * x6, int x7, char const * * x8, int x9, TF_Status * x10)
{
  TF_PRun(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_PRun(PyObject *self, PyObject *args)
{
  TF_Session * x0;
  char const * x1;
  char const * * x2;
  TF_Tensor * * x3;
  int x4;
  char const * * x5;
  TF_Tensor * * x6;
  int x7;
  char const * * x8;
  int x9;
  TF_Status * x10;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;
  PyObject *arg9;
  PyObject *arg10;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 11, "TF_PRun");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];
  arg2 = aa[2];
  arg3 = aa[3];
  arg4 = aa[4];
  arg5 = aa[5];
  arg6 = aa[6];
  arg7 = aa[7];
  arg8 = aa[8];
  arg9 = aa[9];
  arg10 = aa[10];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(59), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Session *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(59), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(19), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(19), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(61), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (char const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(61), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (TF_Tensor * *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(62), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(61), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (char const * *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(61), arg5) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (TF_Tensor * *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(62), arg6) < 0)
      return NULL;
  }

  x7 = _cffi_to_c_int(arg7, int);
  if (x7 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(61), arg8, (char **)&x8);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x8 = (char const * *)alloca((size_t)datasize);
    memset((void *)x8, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x8, _cffi_type(61), arg8) < 0)
      return NULL;
  }

  x9 = _cffi_to_c_int(arg9, int);
  if (x9 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg10, (char **)&x10);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x10 = (TF_Status *)alloca((size_t)datasize);
    memset((void *)x10, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x10, _cffi_type(20), arg10) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_PRun(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_PRun _cffi_d_TF_PRun
#endif

static void _cffi_d_TF_PRunSetup(TF_Session * x0, char const * * x1, int x2, char const * * x3, int x4, char const * * x5, int x6, char * * x7, TF_Status * x8)
{
  TF_PRunSetup(x0, x1, x2, x3, x4, x5, x6, x7, x8);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_PRunSetup(PyObject *self, PyObject *args)
{
  TF_Session * x0;
  char const * * x1;
  int x2;
  char const * * x3;
  int x4;
  char const * * x5;
  int x6;
  char * * x7;
  TF_Status * x8;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 9, "TF_PRunSetup");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];
  arg2 = aa[2];
  arg3 = aa[3];
  arg4 = aa[4];
  arg5 = aa[5];
  arg6 = aa[6];
  arg7 = aa[7];
  arg8 = aa[8];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(59), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Session *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(59), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(61), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(61), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(61), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (char const * *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(61), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(61), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (char const * *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(61), arg5) < 0)
      return NULL;
  }

  x6 = _cffi_to_c_int(arg6, int);
  if (x6 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(84), arg7, (char **)&x7);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x7 = (char * *)alloca((size_t)datasize);
    memset((void *)x7, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x7, _cffi_type(84), arg7) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg8, (char **)&x8);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x8 = (TF_Status *)alloca((size_t)datasize);
    memset((void *)x8, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x8, _cffi_type(20), arg8) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_PRunSetup(x0, x1, x2, x3, x4, x5, x6, x7, x8); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_PRunSetup _cffi_d_TF_PRunSetup
#endif

static void _cffi_d_TF_Reset(TF_SessionOptions const * x0, char const * * x1, int x2, TF_Status * x3)
{
  TF_Reset(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_Reset(PyObject *self, PyObject *args)
{
  TF_SessionOptions const * x0;
  char const * * x1;
  int x2;
  TF_Status * x3;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 4, "TF_Reset");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];
  arg2 = aa[2];
  arg3 = aa[3];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(23), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_SessionOptions const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(23), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(61), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const * *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(61), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, int);
  if (x2 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (TF_Status *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(20), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_Reset(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_Reset _cffi_d_TF_Reset
#endif

static void _cffi_d_TF_Run(TF_Session * x0, TF_Buffer const * x1, char const * * x2, TF_Tensor * * x3, int x4, char const * * x5, TF_Tensor * * x6, int x7, char const * * x8, int x9, TF_Buffer * x10, TF_Status * x11)
{
  TF_Run(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_Run(PyObject *self, PyObject *args)
{
  TF_Session * x0;
  TF_Buffer const * x1;
  char const * * x2;
  TF_Tensor * * x3;
  int x4;
  char const * * x5;
  TF_Tensor * * x6;
  int x7;
  char const * * x8;
  int x9;
  TF_Buffer * x10;
  TF_Status * x11;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject *arg4;
  PyObject *arg5;
  PyObject *arg6;
  PyObject *arg7;
  PyObject *arg8;
  PyObject *arg9;
  PyObject *arg10;
  PyObject *arg11;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 12, "TF_Run");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];
  arg2 = aa[2];
  arg3 = aa[3];
  arg4 = aa[4];
  arg5 = aa[5];
  arg6 = aa[6];
  arg7 = aa[7];
  arg8 = aa[8];
  arg9 = aa[9];
  arg10 = aa[10];
  arg11 = aa[11];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(59), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Session *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(59), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(60), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (TF_Buffer const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(60), arg1) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(61), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (char const * *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(61), arg2) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (TF_Tensor * *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(62), arg3) < 0)
      return NULL;
  }

  x4 = _cffi_to_c_int(arg4, int);
  if (x4 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(61), arg5, (char **)&x5);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x5 = (char const * *)alloca((size_t)datasize);
    memset((void *)x5, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x5, _cffi_type(61), arg5) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(62), arg6, (char **)&x6);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x6 = (TF_Tensor * *)alloca((size_t)datasize);
    memset((void *)x6, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x6, _cffi_type(62), arg6) < 0)
      return NULL;
  }

  x7 = _cffi_to_c_int(arg7, int);
  if (x7 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(61), arg8, (char **)&x8);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x8 = (char const * *)alloca((size_t)datasize);
    memset((void *)x8, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x8, _cffi_type(61), arg8) < 0)
      return NULL;
  }

  x9 = _cffi_to_c_int(arg9, int);
  if (x9 == (int)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(7), arg10, (char **)&x10);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x10 = (TF_Buffer *)alloca((size_t)datasize);
    memset((void *)x10, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x10, _cffi_type(7), arg10) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg11, (char **)&x11);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x11 = (TF_Status *)alloca((size_t)datasize);
    memset((void *)x11, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x11, _cffi_type(20), arg11) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_Run(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_Run _cffi_d_TF_Run
#endif

static void _cffi_d_TF_SetConfig(TF_SessionOptions * x0, void const * x1, size_t x2, TF_Status * x3)
{
  TF_SetConfig(x0, x1, x2, x3);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_SetConfig(PyObject *self, PyObject *args)
{
  TF_SessionOptions * x0;
  void const * x1;
  size_t x2;
  TF_Status * x3;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject *arg3;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 4, "TF_SetConfig");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];
  arg2 = aa[2];
  arg3 = aa[3];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(107), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_SessionOptions *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(107), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(1), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (void const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(1), arg1) < 0)
      return NULL;
  }

  x2 = _cffi_to_c_int(arg2, size_t);
  if (x2 == (size_t)-1 && PyErr_Occurred())
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg3, (char **)&x3);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x3 = (TF_Status *)alloca((size_t)datasize);
    memset((void *)x3, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x3, _cffi_type(20), arg3) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_SetConfig(x0, x1, x2, x3); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_SetConfig _cffi_d_TF_SetConfig
#endif

static void _cffi_d_TF_SetStatus(TF_Status * x0, TF_Code x1, char const * x2)
{
  TF_SetStatus(x0, x1, x2);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_SetStatus(PyObject *self, PyObject *args)
{
  TF_Status * x0;
  TF_Code x1;
  char const * x2;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject *arg2;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 3, "TF_SetStatus");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];
  arg2 = aa[2];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(20), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Status *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(20), arg0) < 0)
      return NULL;
  }

  if (_cffi_to_c((char *)&x1, _cffi_type(130), arg1) < 0)
    return NULL;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(19), arg2, (char **)&x2);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x2 = (char const *)alloca((size_t)datasize);
    memset((void *)x2, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x2, _cffi_type(19), arg2) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_SetStatus(x0, x1, x2); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_SetStatus _cffi_d_TF_SetStatus
#endif

static void _cffi_d_TF_SetTarget(TF_SessionOptions * x0, char const * x1)
{
  TF_SetTarget(x0, x1);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_SetTarget(PyObject *self, PyObject *args)
{
  TF_SessionOptions * x0;
  char const * x1;
  Py_ssize_t datasize;
  PyObject *arg0;
  PyObject *arg1;
  PyObject **aa;

  aa = _cffi_unpack_args(args, 2, "TF_SetTarget");
  if (aa == NULL)
    return NULL;
  arg0 = aa[0];
  arg1 = aa[1];

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(107), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_SessionOptions *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(107), arg0) < 0)
      return NULL;
  }

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(19), arg1, (char **)&x1);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x1 = (char const *)alloca((size_t)datasize);
    memset((void *)x1, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x1, _cffi_type(19), arg1) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { TF_SetTarget(x0, x1); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  Py_INCREF(Py_None);
  return Py_None;
}
#else
#  define _cffi_f_TF_SetTarget _cffi_d_TF_SetTarget
#endif

static size_t _cffi_d_TF_TensorByteSize(TF_Tensor const * x0)
{
  return TF_TensorByteSize(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_TensorByteSize(PyObject *self, PyObject *arg0)
{
  TF_Tensor const * x0;
  Py_ssize_t datasize;
  size_t result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Tensor const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(16), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_TensorByteSize(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_int(result, size_t);
}
#else
#  define _cffi_f_TF_TensorByteSize _cffi_d_TF_TensorByteSize
#endif

static void * _cffi_d_TF_TensorData(TF_Tensor const * x0)
{
  return TF_TensorData(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_TensorData(PyObject *self, PyObject *arg0)
{
  TF_Tensor const * x0;
  Py_ssize_t datasize;
  void * result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Tensor const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(16), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_TensorData(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_pointer((char *)result, _cffi_type(34));
}
#else
#  define _cffi_f_TF_TensorData _cffi_d_TF_TensorData
#endif

static TF_DataType _cffi_d_TF_TensorType(TF_Tensor const * x0)
{
  return TF_TensorType(x0);
}
#ifndef PYPY_VERSION
static PyObject *
_cffi_f_TF_TensorType(PyObject *self, PyObject *arg0)
{
  TF_Tensor const * x0;
  Py_ssize_t datasize;
  TF_DataType result;

  datasize = _cffi_prepare_pointer_call_argument(
      _cffi_type(16), arg0, (char **)&x0);
  if (datasize != 0) {
    if (datasize < 0)
      return NULL;
    x0 = (TF_Tensor const *)alloca((size_t)datasize);
    memset((void *)x0, 0, (size_t)datasize);
    if (_cffi_convert_array_from_object((char *)x0, _cffi_type(16), arg0) < 0)
      return NULL;
  }

  Py_BEGIN_ALLOW_THREADS
  _cffi_restore_errno();
  { result = TF_TensorType(x0); }
  _cffi_save_errno();
  Py_END_ALLOW_THREADS

  (void)self; /* unused */
  return _cffi_from_c_deref((char *)&result, _cffi_type(31));
}
#else
#  define _cffi_f_TF_TensorType _cffi_d_TF_TensorType
#endif

static const struct _cffi_global_s _cffi_globals[] = {
  { "TF_ABORTED", (void *)_cffi_const_TF_ABORTED, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_ALREADY_EXISTS", (void *)_cffi_const_TF_ALREADY_EXISTS, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_BFLOAT16", (void *)_cffi_const_TF_BFLOAT16, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_BOOL", (void *)_cffi_const_TF_BOOL, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_CANCELLED", (void *)_cffi_const_TF_CANCELLED, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_COMPLEX", (void *)_cffi_const_TF_COMPLEX, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_COMPLEX128", (void *)_cffi_const_TF_COMPLEX128, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_COMPLEX64", (void *)_cffi_const_TF_COMPLEX64, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_CloseSession", (void *)_cffi_f_TF_CloseSession, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 72), (void *)_cffi_d_TF_CloseSession },
  { "TF_DATA_LOSS", (void *)_cffi_const_TF_DATA_LOSS, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_DEADLINE_EXCEEDED", (void *)_cffi_const_TF_DEADLINE_EXCEEDED, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_DOUBLE", (void *)_cffi_const_TF_DOUBLE, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_DeleteBuffer", (void *)_cffi_f_TF_DeleteBuffer, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 55), (void *)_cffi_d_TF_DeleteBuffer },
  { "TF_DeleteSession", (void *)_cffi_f_TF_DeleteSession, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 72), (void *)_cffi_d_TF_DeleteSession },
  { "TF_DeleteSessionOptions", (void *)_cffi_f_TF_DeleteSessionOptions, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 106), (void *)_cffi_d_TF_DeleteSessionOptions },
  { "TF_DeleteStatus", (void *)_cffi_f_TF_DeleteStatus, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 125), (void *)_cffi_d_TF_DeleteStatus },
  { "TF_DeleteTensor", (void *)_cffi_f_TF_DeleteTensor, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 133), (void *)_cffi_d_TF_DeleteTensor },
  { "TF_Dim", (void *)_cffi_f_TF_Dim, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 45), (void *)_cffi_d_TF_Dim },
  { "TF_ExtendGraph", (void *)_cffi_f_TF_ExtendGraph, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 100), (void *)_cffi_d_TF_ExtendGraph },
  { "TF_FAILED_PRECONDITION", (void *)_cffi_const_TF_FAILED_PRECONDITION, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_FLOAT", (void *)_cffi_const_TF_FLOAT, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_GetBuffer", (void *)_cffi_f_TF_GetBuffer, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 6), (void *)_cffi_d_TF_GetBuffer },
  { "TF_GetCode", (void *)_cffi_f_TF_GetCode, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 12), (void *)_cffi_d_TF_GetCode },
  { "TF_GetOpList", (void *)_cffi_f_TF_GetOpList, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 9), (void *)_cffi_d_TF_GetOpList },
  { "TF_HALF", (void *)_cffi_const_TF_HALF, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_INT16", (void *)_cffi_const_TF_INT16, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_INT32", (void *)_cffi_const_TF_INT32, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_INT64", (void *)_cffi_const_TF_INT64, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_INT8", (void *)_cffi_const_TF_INT8, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_INTERNAL", (void *)_cffi_const_TF_INTERNAL, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_INVALID_ARGUMENT", (void *)_cffi_const_TF_INVALID_ARGUMENT, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_LoadLibrary", (void *)_cffi_f_TF_LoadLibrary, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 18), (void *)_cffi_d_TF_LoadLibrary },
  { "TF_Message", (void *)_cffi_f_TF_Message, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 39), (void *)_cffi_d_TF_Message },
  { "TF_NOT_FOUND", (void *)_cffi_const_TF_NOT_FOUND, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_NewBuffer", (void *)_cffi_f_TF_NewBuffer, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 4), (void *)_cffi_d_TF_NewBuffer },
  { "TF_NewBufferFromString", (void *)_cffi_f_TF_NewBufferFromString, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 0), (void *)_cffi_d_TF_NewBufferFromString },
  { "TF_NewSession", (void *)_cffi_f_TF_NewSession, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 22), (void *)_cffi_d_TF_NewSession },
  { "TF_NewSessionOptions", (void *)_cffi_f_TF_NewSessionOptions, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 26), (void *)_cffi_d_TF_NewSessionOptions },
  { "TF_NewStatus", (void *)_cffi_f_TF_NewStatus, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_N, 28), (void *)_cffi_d_TF_NewStatus },
  { "TF_NewTensor", (void *)_cffi_f_TF_NewTensor, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 30), (void *)_cffi_d_TF_NewTensor },
  { "TF_NumDims", (void *)_cffi_f_TF_NumDims, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 42), (void *)_cffi_d_TF_NumDims },
  { "TF_OK", (void *)_cffi_const_TF_OK, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_OUT_OF_RANGE", (void *)_cffi_const_TF_OUT_OF_RANGE, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_PERMISSION_DENIED", (void *)_cffi_const_TF_PERMISSION_DENIED, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_PRun", (void *)_cffi_f_TF_PRun, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 87), (void *)_cffi_d_TF_PRun },
  { "TF_PRunSetup", (void *)_cffi_f_TF_PRunSetup, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 76), (void *)_cffi_d_TF_PRunSetup },
  { "TF_QINT16", (void *)_cffi_const_TF_QINT16, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_QINT32", (void *)_cffi_const_TF_QINT32, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_QINT8", (void *)_cffi_const_TF_QINT8, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_QUINT16", (void *)_cffi_const_TF_QUINT16, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_QUINT8", (void *)_cffi_const_TF_QUINT8, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_RESOURCE_EXHAUSTED", (void *)_cffi_const_TF_RESOURCE_EXHAUSTED, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_Reset", (void *)_cffi_f_TF_Reset, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 119), (void *)_cffi_d_TF_Reset },
  { "TF_Run", (void *)_cffi_f_TF_Run, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 58), (void *)_cffi_d_TF_Run },
  { "TF_STRING", (void *)_cffi_const_TF_STRING, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_SetConfig", (void *)_cffi_f_TF_SetConfig, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 113), (void *)_cffi_d_TF_SetConfig },
  { "TF_SetStatus", (void *)_cffi_f_TF_SetStatus, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 128), (void *)_cffi_d_TF_SetStatus },
  { "TF_SetTarget", (void *)_cffi_f_TF_SetTarget, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_V, 109), (void *)_cffi_d_TF_SetTarget },
  { "TF_TensorByteSize", (void *)_cffi_f_TF_TensorByteSize, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 49), (void *)_cffi_d_TF_TensorByteSize },
  { "TF_TensorData", (void *)_cffi_f_TF_TensorData, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 52), (void *)_cffi_d_TF_TensorData },
  { "TF_TensorType", (void *)_cffi_f_TF_TensorType, _CFFI_OP(_CFFI_OP_CPYTHON_BLTN_O, 15), (void *)_cffi_d_TF_TensorType },
  { "TF_UINT16", (void *)_cffi_const_TF_UINT16, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_UINT8", (void *)_cffi_const_TF_UINT8, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_UNAUTHENTICATED", (void *)_cffi_const_TF_UNAUTHENTICATED, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_UNAVAILABLE", (void *)_cffi_const_TF_UNAVAILABLE, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_UNIMPLEMENTED", (void *)_cffi_const_TF_UNIMPLEMENTED, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
  { "TF_UNKNOWN", (void *)_cffi_const_TF_UNKNOWN, _CFFI_OP(_CFFI_OP_ENUM, -1), (void *)0 },
};

static const struct _cffi_field_s _cffi_fields[] = {
  { "data", offsetof(TF_Buffer, data),
            sizeof(((TF_Buffer *)0)->data),
            _CFFI_OP(_CFFI_OP_NOOP, 1) },
  { "length", offsetof(TF_Buffer, length),
              sizeof(((TF_Buffer *)0)->length),
              _CFFI_OP(_CFFI_OP_NOOP, 2) },
  { "data_deallocator", offsetof(TF_Buffer, data_deallocator),
                        sizeof(((TF_Buffer *)0)->data_deallocator),
                        _CFFI_OP(_CFFI_OP_NOOP, 154) },
};

static const struct _cffi_struct_union_s _cffi_struct_unions[] = {
  { "$TF_Buffer", 145, _CFFI_F_CHECK_FIELDS,
    sizeof(TF_Buffer), offsetof(struct _cffi_align_typedef_TF_Buffer, y), 0, 3 },
  { "TF_Library", 146, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "TF_Session", 147, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "TF_SessionOptions", 148, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "TF_Status", 149, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
  { "TF_Tensor", 150, _CFFI_F_OPAQUE,
    (size_t)-1, -1, -1, 0 /* opaque */ },
};

static const struct _cffi_enum_s _cffi_enums[] = {
  { "$TF_Code", 130, _cffi_prim_int(sizeof(TF_Code), ((TF_Code)-1) <= 0),
    "TF_OK,TF_CANCELLED,TF_UNKNOWN,TF_INVALID_ARGUMENT,TF_DEADLINE_EXCEEDED,TF_NOT_FOUND,TF_ALREADY_EXISTS,TF_PERMISSION_DENIED,TF_UNAUTHENTICATED,TF_RESOURCE_EXHAUSTED,TF_FAILED_PRECONDITION,TF_ABORTED,TF_OUT_OF_RANGE,TF_UNIMPLEMENTED,TF_INTERNAL,TF_UNAVAILABLE,TF_DATA_LOSS" },
  { "$TF_DataType", 31, _cffi_prim_int(sizeof(TF_DataType), ((TF_DataType)-1) <= 0),
    "TF_FLOAT,TF_DOUBLE,TF_INT32,TF_UINT8,TF_INT16,TF_INT8,TF_STRING,TF_COMPLEX64,TF_COMPLEX,TF_INT64,TF_BOOL,TF_QINT8,TF_QUINT8,TF_QINT32,TF_BFLOAT16,TF_QINT16,TF_QUINT16,TF_UINT16,TF_COMPLEX128,TF_HALF" },
};

static const struct _cffi_typename_s _cffi_typenames[] = {
  { "TF_Buffer", 145 },
  { "TF_Code", 130 },
  { "TF_DataType", 31 },
  { "TF_Library", 146 },
  { "TF_Session", 147 },
  { "TF_SessionOptions", 148 },
  { "TF_Status", 149 },
  { "TF_Tensor", 150 },
};

static const struct _cffi_type_context_s _cffi_type_context = {
  _cffi_types,
  _cffi_globals,
  _cffi_fields,
  _cffi_struct_unions,
  _cffi_enums,
  _cffi_typenames,
  67,  /* num_globals */
  6,  /* num_struct_unions */
  2,  /* num_enums */
  8,  /* num_typenames */
  NULL,  /* no includes */
  156,  /* num_types */
  0,  /* flags */
};

#ifdef PYPY_VERSION
PyMODINIT_FUNC
_cffi_pypyinit__tensor_c_api(const void *p[])
{
    p[0] = (const void *)0x2601;
    p[1] = &_cffi_type_context;
}
#  ifdef _MSC_VER
     PyMODINIT_FUNC
#  if PY_MAJOR_VERSION >= 3
     PyInit__tensor_c_api(void) { return NULL; }
#  else
     init_tensor_c_api(void) { }
#  endif
#  endif
#elif PY_MAJOR_VERSION >= 3
PyMODINIT_FUNC
PyInit__tensor_c_api(void)
{
  return _cffi_init("_tensor_c_api", 0x2601, &_cffi_type_context);
}
#else
PyMODINIT_FUNC
init_tensor_c_api(void)
{
  _cffi_init("_tensor_c_api", 0x2601, &_cffi_type_context);
}
#endif
